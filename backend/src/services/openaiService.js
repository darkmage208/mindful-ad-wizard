import OpenAI from 'openai';
import { logger } from '../utils/logger.js';

// Initialize OpenAI client
let openai = null;

if (process.env.OPENAI_API_KEY) {
  openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY,
  });
} else {
  logger.warn('OpenAI API key not configured');
}

/**
 * Generate AI content using OpenAI GPT
 * @param {string} type - Type of content (headline, description, keywords, etc.)
 * @param {object} context - Context for content generation
 * @returns {Promise<string>} Generated content
 */
export const generateAIContent = async (type, context) => {
  if (!openai) {
    throw new Error('OpenAI service not configured');
  }

  try {
    const prompt = buildPrompt(type, context);
    
    const response = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: 'You are an expert digital marketing copywriter specializing in psychology practice advertising. You understand the unique challenges and opportunities in mental health marketing, including ethical considerations and professional standards.',
        },
        {
          role: 'user',
          content: prompt,
        },
      ],
      max_tokens: 1000,
      temperature: 0.7,
      top_p: 0.9,
    });

    const content = response.choices[0]?.message?.content;
    
    if (!content) {
      throw new Error('No content generated by OpenAI');
    }

    logger.info(`AI content generated: ${type}`, {
      tokensUsed: response.usage?.total_tokens,
    });

    return content;
  } catch (error) {
    logger.error('OpenAI content generation failed:', error);
    throw new Error(`AI content generation failed: ${error.message}`);
  }
};

/**
 * Generate AI chat response
 * @param {string} message - User message
 * @param {object} context - Additional context (campaigns, user data, etc.)
 * @returns {Promise<string>} AI response
 */
export const generateChatResponse = async (message, context = {}) => {
  if (!openai) {
    throw new Error('OpenAI service not configured');
  }

  try {
    const systemMessage = buildChatSystemMessage(context);
    
    const response = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: systemMessage,
        },
        {
          role: 'user',
          content: message,
        },
      ],
      max_tokens: 800,
      temperature: 0.8,
      top_p: 0.9,
    });

    const responseContent = response.choices[0]?.message?.content;
    
    if (!responseContent) {
      throw new Error('No response generated by OpenAI');
    }

    logger.info('AI chat response generated', {
      tokensUsed: response.usage?.total_tokens,
    });

    return responseContent;
  } catch (error) {
    logger.error('OpenAI chat response failed:', error);
    throw new Error(`AI chat failed: ${error.message}`);
  }
};

/**
 * Analyze campaign performance and provide recommendations
 * @param {object} campaign - Campaign data
 * @returns {Promise<object>} Analysis and recommendations
 */
export const analyzeCampaignPerformance = async (campaign) => {
  if (!openai) {
    throw new Error('OpenAI service not configured');
  }

  try {
    const analysisPrompt = `
Analyze the following psychology practice advertising campaign performance and provide actionable recommendations:

Campaign: ${campaign.name}
Platform: ${campaign.platform}
Budget: $${campaign.budget}
Target Audience: ${campaign.targetAudience}
Objectives: ${campaign.objectives.join(', ')}

Performance Metrics:
- Impressions: ${campaign.impressions || 0}
- Clicks: ${campaign.clicks || 0}
- Conversions: ${campaign.conversions || 0}
- Cost: $${campaign.cost || 0}
- Leads: ${campaign.leads || 0}
- CTR: ${campaign.impressions > 0 ? ((campaign.clicks / campaign.impressions) * 100).toFixed(2) : 0}%
- CPC: $${campaign.clicks > 0 ? (campaign.cost / campaign.clicks).toFixed(2) : 0}
- CPL: $${campaign.leads > 0 ? (campaign.cost / campaign.leads).toFixed(2) : 0}

Provide:
1. Performance analysis (2-3 sentences)
2. Top 3 specific recommendations for improvement
3. Suggested budget reallocation if needed
4. Red flags or concerns (if any)

Keep recommendations practical and specific to psychology practice marketing.
    `;

    const response = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: 'You are a digital marketing expert specializing in psychology practice advertising. Provide data-driven, actionable insights while considering ethical marketing standards in mental health.',
        },
        {
          role: 'user',
          content: analysisPrompt,
        },
      ],
      max_tokens: 1200,
      temperature: 0.6,
    });

    const analysis = response.choices[0]?.message?.content;
    
    if (!analysis) {
      throw new Error('No analysis generated');
    }

    // Parse the analysis into structured data
    const sections = analysis.split('\
\
');
    
    return {
      insights: analysis,
      recommendations: extractRecommendations(analysis),
      summary: sections[0] || 'Analysis completed',
    };
  } catch (error) {
    logger.error('Campaign analysis failed:', error);
    throw new Error(`Campaign analysis failed: ${error.message}`);
  }
};

/**
 * Build content generation prompt based on type
 */
const buildPrompt = (type, context) => {
  const baseContext = `
Context:
- Target Audience: ${context.targetAudience}
- Service Type: ${context.serviceType || 'Psychology Practice'}
- Platform: ${context.platform}
- Budget: $${context.budget}
- Objectives: ${context.objectives?.join(', ') || 'Not specified'}
  `;

  switch (type) {
    case 'headline':
      return `
Create 5 compelling ad headlines for a psychology practice. Each headline should:
- Be 25-40 characters for optimal display
- Include emotional triggers appropriate for mental health
- Avoid medical claims or promises
- Be professional yet approachable
- Include relevant keywords for the target audience

${baseContext}

Return only the headlines, one per line, without numbers or bullets.
      `;

    case 'description':
      return `
Create 5 ad descriptions for a psychology practice. Each description should:
- Be 80-120 characters
- Include a clear call-to-action
- Highlight benefits, not just features
- Be empathetic and professional
- Comply with mental health advertising standards
- Include relevant keywords naturally

${baseContext}

Return only the descriptions, one per line, without numbers or bullets.
      `;

    case 'keywords':
    case 'ad-copy':
      return `
Generate 15-20 relevant keywords for psychology practice advertising. Include:
- Service-specific terms (therapy types, specializations)
- Location-based keywords (if applicable)
- Problem/solution keywords (anxiety help, depression support)
- Long-tail keywords for better targeting
- Professional terms (licensed therapist, psychologist)

${baseContext}

Return only the keywords, one per line, without quotes or numbers.
      `;

    case 'landing-page-copy':
      return `
Create compelling landing page copy for a psychology practice including:
- Main headline (emotional, benefit-focused)
- Subheadline (supportive, credibility-building)
- 3 key benefits or services
- Call-to-action text
- Trust elements (credentials, experience)

${baseContext}

Format as structured sections.
      `;

    default:
      return `Generate marketing content of type \"${type}\" for a psychology practice.\
${baseContext}`;
  }
};

/**
 * Build chat system message with context
 */
const buildChatSystemMessage = (context) => {
  let systemMessage = `
You are an AI marketing assistant specifically designed for psychology professionals. You help with:

- Campaign strategy and optimization
- Ad copy and content creation
- Audience targeting advice
- Performance analysis and recommendations
- Compliance with mental health advertising ethics
- Lead generation strategies
- Budget optimization

Always:
- Provide actionable, specific advice
- Consider ethical standards in mental health marketing
- Avoid making medical claims or promises
- Focus on professional, empathetic messaging
- Suggest data-driven optimizations when possible
  `;

  if (context.campaigns && context.campaigns.length > 0) {
    systemMessage += `

User's Current Campaign Context:
`;
    context.campaigns.forEach((campaign, index) => {
      systemMessage += `
Campaign ${index + 1}: ${campaign.name}
- Platform: ${campaign.platform}
- Status: ${campaign.status}
- Budget: $${campaign.budget}
- Leads: ${campaign.metrics?.leads || 0}
- Cost: $${campaign.metrics?.cost || 0}
      `;
    });
  }

  if (context.totalCampaigns) {
    systemMessage += `

User has ${context.totalCampaigns} total campaigns, ${context.activeCampaigns || 0} active.`;
  }

  return systemMessage;
};

/**
 * Extract recommendations from analysis text
 */
const extractRecommendations = (analysis) => {
  const recommendations = [];
  const lines = analysis.split('\
');
  
  let inRecommendations = false;
  for (const line of lines) {
    if (line.toLowerCase().includes('recommendation')) {
      inRecommendations = true;
      continue;
    }
    
    if (inRecommendations) {
      const trimmed = line.trim();
      if (trimmed && (trimmed.match(/^\\d+\\./) || trimmed.match(/^-/) || trimmed.match(/^\\*/))) {
        recommendations.push(trimmed.replace(/^[\\d\\.\\-\\*\\s]+/, '').trim());
      }
      
      // Stop if we hit another section
      if (trimmed.toLowerCase().includes('budget') || trimmed.toLowerCase().includes('red flags')) {
        break;
      }
    }
    
    if (recommendations.length >= 5) break; // Limit recommendations
  }
  
  return recommendations;
};

/**
 * Test OpenAI connection
 */
export const testOpenAIConnection = async () => {
  if (!openai) {
    return { success: false, error: 'OpenAI not configured' };
  }

  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [{ role: 'user', content: 'Hello' }],
      max_tokens: 5,
    });

    return { success: true, model: 'gpt-3.5-turbo' };
  } catch (error) {
    return { success: false, error: error.message };
  }
};